# Preventing action loops

### How to Prevent Action Loops in Mechanic Tasks

Action loops can occur when a Mechanic task triggers an action that, in turn, generates an event that re-triggers the same task. This can lead to unintended consequences like excessive API calls, duplicated data, or even rate-limiting issues. This guide aims to provide you with strategies to prevent such action loops in your Mechanic tasks.

### Manual Prevention

#### 1. Conditional Checks

#### **Example: Skip Tagging if Tag Already Exists**

{% code lineNumbers="true" fullWidth="true" %}
```liquid
{% raw %}
{% if event.topic == "shopify/products/update" or event.preview %}
  {% assign existing_tags = product.tags | split: ", " %}
  
  {% unless existing_tags contains "NewTag" %}
    {% action "shopify" %}
      mutation {
        tagsAdd(
          id: {{ product.admin_graphql_api_id | json }},
          tags: ["NewTag"]
        ) {
          userErrors {
            field
            message
          }
        }
      }
    {% endaction %}
  {% else %}
    {% log "break loop" %}
  {% endunless %}
{% endif %}
{% endraw %}
```
{% endcode %}

#### 2. Timestamp-based Approach

**Example: Using Timestamps to Prevent Loops**

{% code lineNumbers="true" fullWidth="true" %}
```liquid
{% raw %}
{% if event.topic == "shopify/products/update" or event.preview %}
  {% assign current_timestamp = "now" | date: "%s" %}
  {% assign time_difference = current_timestamp | minus: product.metafields.custom.last_updated.value %}
  
  {% if time_difference >= 500 %}
    {% action "shopify" %}
      mutation {
        productUpdate(
          input: {
            id: {{ product.admin_graphql_api_id | json }},
            metafields: [{
              id: {{ product.metafields.custom.last_updated.metafield.admin_graphql_api_id | json }},
              namespace: "custom",
              key: "last_updated",
              value: {{ current_timestamp | json }},
              type: "number_integer"
            }]
          }
        ) {
          userErrors {
            field
            message
          }
        }
      }
    {% endaction %}
    {% comment %}
      Do your update here
    {% endcomment %}
  {% else %}
    {% log "not so fast" %}
  {% endif %}
{% endif %}
{% endraw %}
```
{% endcode %}

### Automated Prevention

#### Mechanic's Built-in Features

Mechanic has some built-in features to prevent action loops:

1. For tasks responding to `mechanic/actions/perform`, Mechanic will detect identical results to their predecessors and mark the task run as failed.
2. For tasks responding to Shopify update events like `shopify/products/update`, Mechanic will detect repeated, identical task runs and error all action runs generated by the flagged task run.

### Conclusion

Preventing action loops is crucial for maintaining the efficiency and reliability of your Mechanic tasks. By implementing conditional checks or using a timestamp-based approach, you can ensure that your tasks operate as intended without causing unintended loops.
